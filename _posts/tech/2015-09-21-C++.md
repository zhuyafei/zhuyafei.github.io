---
layout: post
title: C/C++基本概念梳理
category: 技术
---
## 1. 基本介绍
编程语言总的来说可以分为机器语言、汇编语言、高级语言三大类。C++属于高级语言，它所编制的程序不能直接被计算机识别，必须经过转换才能被执行，转换方式分为两类：
解释类：执行方式类似于我们日常生活中的“同声翻译”，应用程序源代码一边由相应语言的解释器“翻译”成目标代码（机器语言），一边执行，因此效率比较低，而且不能生成可独立执行的可执行文件，应用程序不能脱离其解释器，但这种方式比较灵活，可以动态地调整、修改应用程序。如较早时期的Qbasic语言。
编译类：编译是指在应用源程序执行之前，就将程序源代码“翻译”成目标代码（机器语言），因此其目标程序可以脱离其语言环境独立执行，使用比较方便、效率较高。但应用程序一旦需要修改，必须先修改源代码，再重新编译生成新的目标文件（OBJ文件）才能执行，只有目标文件而没有源代码，修改很不方便。

## 2. 面向对象的多态性
多态是一个事物有多种形态的意思。面向对象的多态性指的是对不同类的对象发送同一个消息，这些不同类的对象在接收时会有不同的行为。也就是说，当我们调用同一形式的函数时，不同类的对象分别执行功能不同的函数。多态性分为两类：静态多态性和动态多态性，又称编译时的多态性和运行时的多态性。静态多态性是通过函数重载和运算符重载实现的。动态多态性通过虚函数来实现。

当一个基类被继承为不同的派生类时，各个派生类可以使用与基类成员相同的成员名，那么编译系统会按照同名覆盖(派生类的函数覆盖基类中的同名函数)的原则决定如何调用。如果有某派生类对象，它调用基类成员函数和派生类中的同名成员函数的形式是不一样的，这样很不方便。并且，如果用指向基类的指针指向某一派生类对象，用这个指针调用派生类成员函数会失败，这是因为会自动进行指针类型转换，将派生类对象的指针转换为基类的指针，这样，基类指针指向的是派生类对象中的基类部分。于是想有一种方法可以用同一个调用形式来调用派生类和基类的同名函数。这就用到虚函数，虚函数，就是在基类中声明函数是虚拟的，并不是实际存在的函数，然后在派生类中才正式定义此函数，也就是派生类可以改变基类同名函数的行为。这样在运行时，用指向基类的指针指向某一派生类对象，通过该指针可以调用派生类中的成员函数。现在用同一种调用形式pt->display()，而且pt是同一个基类指针，可以调用同一类族中不同类的虚函数。

## 3. C++的类和C里面的struct有什么区别？
C++的class具有数据封装功能，其中各成员的访问属性可以是private，public和protect，还具有能实现类接口功能和辅助功能的操作函数，而C里面的struct访问权限只有public，没有数据封装功能，并且struct本身不含有操作函数，只有数据。

但是现在C++中仍然保留了C里面的结构体类型(struct)，并且把它的功能扩展了。C++里的结构体类型也可以包括成员函数，也具有类的特点(封装)，两者的区别是用struct声明的类，如果对其成员不作private或public的声明，系统将其默认为public。而用class定义的类，如果不作private或public的声明，系统将其成员默认为private。

## 4. 结构体和共用体有什么区别？
共用体的成员共用一块内存区，结构体的成员有各自独立的内存区。

## 5. 作用域和存储器
变量的两种属性：作用域和存储期(也称生命期)。

作用域是从空间的角度来分析的，分为全局变量和局部变量。在一个函数内部定义的变量是内部变量，它只在本函数范围内有效，这些内部变量称为局部变量。在函数之外定义的变量是外部变量，称为全局变量。

存储期是指变量在内存中的存在周期。存储期可以分为静态存储期和动态存储期。这是由变量的静态存储方式和动态存储方式决定的。所谓静态存储方式是指在程序运行期间，系统对变量分配固定的存储空间。而动态存储方式则是在程序运行期间，系统对变量动态地分配存储空间。

内存中供用户使用的存储空间可以分为3部分，即

* 程序区
* 静态存储区
* 动态存储区

程序中所用的数据分别存放在静态存储区和动态存储区中。全局变量全部存放在静态存储区中，在程序开始执行时给全局变量分配存储单元，程序执行完毕就释放这些空间。在程序执行过程中它们占据固定的存储单元。
在动态存储区中存放以下数据：

		(1) 函数形式参数
		(2) 函数中定义变量(未加static声明的局部变量)
		(3) 函数调用时的现场保护和返回地址等

对以上这些数据，在函数调用开始时分配动态存储空间，函数调用结束时释放这些空间。在程序执行过程中，这种分配和释放是动态的。

## 6. 如何判断变量的作用域和存储期？
要判断变量的作用域和存储期，除了要看变量是在函数内还是函数外定义的，还要看它们的存储类别，这是变量除了数据类型外的另一属性。
存储类别有4种：自动的(`auto`)，静态的(`static`)，寄存器的(`register`)，外部的(`extern`)。

* auto
	auto关键字用于声明函数中的局部变量，编译系统对它们是动态地分配存储空间的，这类局部变量称为自动变量，关键字auto可以省略。
* static
	* 用static声明局部变量
		这种局部变量称为静态局部变量，有以下特点：
			1. 静态局部变量在静态存储区内分配存储单元。在程序整个运行期间都不释放。
			2. 对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上一次函数调用结束时的值。
			3. 如果在定义局部变量时不赋初值的话，对静态局部变量来说，编译时自动赋初值0(对数值型变量)或空字符(对字符变量)。
			4. 作用域仍然是局部的，无法被其它函数所引用。	
	* 用static声明全局变量
		这种全局变量又称为静态全局变量，在定义全局变量时加上一个static声明，就能限制该全局变量只被本文件引用，而不能被其他文件引用。普通的全局变量与静态全局变量都用静态存储方式，只是作用范围不同而已，都是在编译时分配内存的。
	* static用于一个函数前
		该函数只能在同一个文件中被调用。
* extern
	extern只能用来声明已定义的全局变量，而不能用于变量的定义。全局变量是在函数的外部定义的，它的作用域是从变量的定义处开始，到本程序文件的末尾。在此作用域内，全局变量可以为本文件中各个函数所引用。有两种情况：1）外部变量不在文件的开头定义，其有效范围只限于定义的位置起到文件终了的位置止。现在在定义点之前的函数想引用该全局变量；2）程序由多个源程序文件组成，在一个文件中想引用另一个文件中已定义的全局变量。这就需要用extern来声明全局变量，以扩展全局变量的作用域。
* register
	一般情况下，变量(包括静态存储方式和动态存储方式)的值是存放在内存中的。当程序中要用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到CPU的运算器中。经过运算器进行运算，如果需要存数，再从运算器将数据送到内存存放。如果一些变量使用频繁，那么为存取变量的值就要花不少的时间。为提高执行效率，C++运行将局部变量的值放在CPU的寄存器中，需要时直接从寄存器中存取。对寄存器的存取速度远高于对内存的存取速度。用关键字register声明，又称为寄存器变量。

## 7. 什么叫宏？谈谈带参数的宏与内联函数之间的异同点。
宏定义是C语言提供的三种预处理功能的其中一种，这三种预处理包括：宏定义、文件包含、条件编译。宏定义又包括带参数的宏定义和不带参数的宏定义。具体是指用一个指定的标识符来进行简单的字符串或参数替换。
内联函数：调用函数时需要一定的时间和空间的开销。函数调用的过程：1）程序先执行函数调用之前的语句；2）流程的控制转移到被调用函数的入口处，同时进行参数传递；3）执行被调用函数中函数体的语句；4）流程返回调用函数的下一条指令处，将函数的返回值带回；5）接着执行主调函数中未执行的语句。这样就要求在转去被调用函数之前，要记下当时执行的指令的地址，还要“保护现场”（记下当时有关的信息），以便在函数调用之后继续执行。在函数调用后，流程返回到先前记下的地址处，并且根据记下的信息“恢复现场”，然后继续执行。这些都要花费一定的时间。
C++提供了一种提高效率的方法，即在编译时将所调用函数的代码直接嵌入到主调函数中，而不是将流程转出去。这种嵌入到主调函数中的函数称为内联函数。
有参数的宏定义只做简单的参数替换，而内联函数可以进行参数类型检查。宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。

## 8. 转换构造函数与类型转换函数
这两种函数都是类的成员函数。转换构造函数是将一个其他类型的数据转换成一个类的对象。类型转换函数的作用是将一个类的对象转换成另一类型的数据。

## 9. 死循环

## 10. C++字符串和整型的相互转换

* 利用C语言的函数atoi和itoa
atoi是把字符串转换成整型数的一个函数，函数原型为：int atoi(const char *nptr);
itoa的功能是把一个整数转换为字符串，函数原型为：char *itoa(int value, char *string, int radix);
参数说明：
value：欲转换的数据
string：目标字符串的地址
radix：转换后的进制数，可以是10进制、16进制等
需要用到的头文件：stdlib.h

## 11. 求一个整数的位数
#include <iostream>
using namespace std;

int main()
{
    int a;
    cin>>a;
    int k=0;
    while (a) {
        a=a/10;
        k++;
    }
    cout<<k<<endl;
}

## 12. 内存基本构成
可编程内存基本上分为三大部分：静态存储区、堆区和栈区。它们的功能不同，对他们的使用方式也就不同。
静态存储区：内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。
栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。

## 13. 一个文件引用另一个文件中的变量或函数
引用变量：需要在本文件中用extern对变量进行声明，表明该变量的定义在别处。如果不加extern，就变成了定义了，定义只能出现一次。
引用函数：在本文件中对函数进行声明就可以，不用加上extern关键字，因为函数默认就是外部的。
